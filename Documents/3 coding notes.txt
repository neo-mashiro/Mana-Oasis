RIDER must-remember-hotkeys:
- ALT + ENTER   // auto inspection, suggest make changes
- double SHIFT  // search everywhere
- ALT + SHIFT   // multi select cursor
- ALT + SHIFT + INSERT  // column mode

4. don’t use GameObject.Findxxx to locate stuff, never use it, instead, make it a SerializeField and drag it in there, even for arrays
6. remember that StringBuilder is much more efficient than strings, don't use strings if possible
7. Minimise use of delegate
8. Think twice before you choose what time to use!!! the following cases are noteworthy.
Instead of Time.deltaTime, use Time.unscaledDeltaTime?
Instead of Time.fixedDeltaTime use Time.fixedUnscaledDeltaTime?
Instead of Time.time, use Time.unscaledTime?
Unity manual says that we should avoid using Time.time per frame, but this is wrong. Feel free to use it, there are no performance issues, and everybody else is using it. In fact we don't have another property to use. At least, Time.time is better than timeSinceLevelLoad.

SetActive is for gameObjects（go）and enabled is for Components on the Object，所以我们我们设置active状态是针对gameObjects而言的，而当具体某个gameObject被active以后，在那个object的挂载的component脚本中，我们要用onEnable去判断（判断这个脚本component被enable了）。设置enable flag则是针对具体某个component而言的。换句话说，setactive是把一整个gameobject前面的勾打上或去掉，设置enable=true or false是把某个component前面的勾打上或去掉。
判断一个go是否active通常用isActiveInHierarchy，也就是说必须它的所有parent也active，否则只要有一个parent不是active，哪怕这个go本身是active，它也不会被update不会起作用。判断一个component是否enabled通常用isActiveAndEnabled，就是这个component对应的go首先要active然后它enabled才有意义，否则只看enabled为true并不代表这个component在起作用，很可能它attach的go是inactive的。

debug UI的时候，不用自己写log，可以直接点击Hierarchy窗口中的EventSystem go，然后在inspector的最下方就能看到eventsystem的实时debug信息表。
debug某个go的时候，往往我们也可以把Inspector切换成debug mode，可以直接动态地看到所有private变量的实时更新情况。

GameObject and all of its component exist before awake is called. This means you can call GetComponent in Awake(), 但是要注意，awake里面不可以访问你定义的变量。以下是best practice：
Awake: Here you setup the component you are on right now (the "this" object)
Start: Here you setup things that depend on other components.
当第一个Start被call的时候，整个游戏里所有脚本的Awake都已经运行完了。
如果一个go一开始是inactive的，awake和start都不会被call，只有当它在游戏中被active了以后，awake、start和OnEnable才会被调用。

如果你确定某个go或component不会被destroy，那么判断它是否为null时，用!ReferenceEquals(go, null)，相比而言，!=null非常昂贵。

use ctrl+shift+n to create a new empty gameobject
use alt+shift+n to create a new empty child gameobject of the selected gameobject
还可以用ctrl+shift来拖动一个物体，该物体会自动snap到其他的ground或物体上（snap的双方必须都有collider才行，没有collider不起作用）
这个叫做surface snapping，用的时候保证Gizmos切换成center而不是pivot模式，对于在terrain上搭建筑非常有用。
还可以按住V来做Vertex snapping。

为什么我在scene view里看到的一个go的xyz坐标方向不对，或者是歪的？
1. 在最上方工具栏里，把local模式切换成global模式就好了
为什么我在inspector里看到一个go的transform.position和scene view里的xyz坐标位置不匹配？
1. 首先，检查一下你这个go是不是child，它的parent的position是不是000，如果有parent，那么position的值是相对parent的位置。
2. pivot模式下，点击一个go所显示的xyz坐标位置，就是该go所对应的transform在world space的position，而在center模式下，xyz坐标位置显示的是物体中心。
3. 检查下你的go的rotation是多少，是不是被倒过来翻转了？

OnDrawGizmos()只会在editor中运行，开发的时候起作用。正式build的时候是不会跑的，请放心。
如果有函数不确定的话，加上[Conditional("UNITY_EDITOR")]的attribute就好了，这个等同于#IF UNITY_EDITOR directive语句，但更高级。

如果particle的数量达到几万几百万数量级，为了性能不要用Unity自带的particle system，而是要用Visual Effect Graph，直接在GPU上面跑的，用来模拟规模非常大的粒子效果，比如战争迷雾这种。

关于Unity与C#的序列化与反序列化，BinaryFormatter/XML/JSON，各种SerializeField/HideInInspector/NonSerialzed/Serializable的区别与比较：
https://zhuanlan.zhihu.com/p/27990334
NonSerialized主要是用来避免序列化一个变量，于是Unity或其他Json或二进制序列化不会包含这个字段，也就是在任何data打包传送的过程中，此字段都会被忽略。（比如，clone或instantiate一个go时，unity就会需要去序列化该go；还有当unity想要把脚本里的字段显示在editor中，也必然有个序列化反序列化即save/load的过程）。一般来说，私有变量用private就可以，如果又想保护数据以防被改，又想被其他类访问到，就用[NonSerialized] public（当然也可以为这个字段专门设一个public getter property，但很麻烦也未必适用，property是用于专门为了给其他类访问的变量用的，预计会被频繁访问，如果只是偶尔有可能会被访问到，还是NonSerialized合适）。再有就是比如一些c#无法存储的texture/bitmap之类的变量，不应该也不能被序列化，就要用NonSerialized。通常NonSerialized最常见的用法，还是为了保护某些字段的数据，而这些字段又偶尔可能会被访问到所以无法设成private。

anchor是一个UI元素的Rect Transform相对于它的parent的Rect Transform的位置。anchor中的min max值，指的是anchor相对于parent Rect Transform的位置，是一个百分比例，当parent的scale发生变化时（切换分辨率），anchor的值能够保证anchor相对parent永远处于同一个位置，比如水平30%垂直50%等等。同样的，pivot的值也是一个百分比，指的是pivot在当前UI元素中的相对位置。
在UI元素的Rect Transform中，POS X Y的值，指的是该元素的pivot距离anchor有多远。当pivot和anchor重合时，pos x y永远为0.
在调UI的时候，不要直接去改POS X Y的值，先确定好anchor和pivot的位置（最好用九宫格Rect Tool），然后有必要了再去改POS，否则一团糟。

Destroy(gameObject);                 // Removes the go, all its components and children
Destroy(this);                       // Removes this script instance from the game object
Destroy(GetComponent<Rigidbody>());  // Removes the rigidbody from the game object
DestroyImmediate();                  // 千万不要用，非常危险！！！可能会删除你的prefab和其他asset！

PhysX的重力加速度是常数，默认9.81，可以在脚本中通过Physics.gravity.y访问，也可以在Physics project settings中设置。对于某个特殊的scene比如月球场景，可以在loadScene时把Physics.gravity设置成Vector3(0, -4.9f, 0)，即地球的一半，不过要记得换场景时设回-9.81f。

实现一个物体在两点之间来回bounce，有几种方法。首先是Mathf.PingPong，像乒乓球一样反弹，然后还可以用两个方向相反的lerp族函数，使得反弹平滑，再有就是利用三角函数sin,cos，利用sine wave自然的平滑性质，并且可以自己调节wave的形状和频率，实现各种效果。

Unity不支持多线程，你可以在自己的纯C#脚本里用多线程，但不能在monobehavior class里用多线程，因为多线程脚本是无法访问任何Unity的API的（因为Unity的API并不是线程安全的）。同时，在你的纯C#脚本里，也要小心保证用到的都是.net的线程安全的函数。这是不是代表Unity很没有效率？不是：
Unity的内部还是有很多地方用到多线程的，比如scheduling，job system，audio，网络通讯，mesh skinner等等，只不过Unity不允许开发者在与Mono相关的game-level的代码中使用多线程，这是为了保证Unity内部的多线程状态稳定。但我们其实还是可以在纯C#脚本中使用多线程，比如可以用来跑后台的批处理什么的。实际中最常见的用例是：处理文件IO读写，处理网络通讯，计算pathfinding等等这些和mono独立的部分。这些功能如果要实现的话，完全不需要和Unity挂钩，而是应该做成单独的模块，在普通的.net solution里开发和测试好，再直接提供数据给Unity使用。
除了这些比较重大的模块之外，我们在开发时最可能会用到多线程的地方，就是Unity自带的Job System，具体参考文档。这是唯一一个我们可以按照Unity规范来安全的使用多线程的地方，但其实用的还是Unity的API，多线程是发生在底层的，Unity自动帮我们处理并发问题，我们只要会schedule job就好了。注意别schedule太多。
https://docs.unity3d.com/Manual/JobSystem.html
要注意一点，Unity自带的coroutine和多线程没有任何关系，只是让你产生好像是多线程的错觉而已，本质还是在一个core上运行的，由CPU调度计划以interleaved的方式执行代码，而并没有涉及到任何线程之间的context switching（上下文切换很expensive），所以才很light-weight。

对象池的池子用Dictionary+queue的数据结构来存储，可以提高查找性能，比如预生成150个子弹+200块石头，那么Dictionary就有两个键值对，{'子弹':queue()}, {'石头':queue()}，key是某类go的tag字符串，value是存储该类go的一个队列。这样设计，每次fetch的时候传入一个tag，就不需要遍历数组了，直接O(1)时间找到该类tag所对应的queue，然后也不需要遍历queue，直接Dequeue()弹出第一个对象即可，将其设为active，再重新Enqueue()入队到最后。如此一来，每次fetch都只用O(1)的时间来完成，最效率。之前我用的是array数组，每次要遍历才能找到一个inactive的对象，返回它再将它设成active，很慢，而且一旦数组的对象全部用光了，所有对象都是active的，那么就fetch不到了。而利用queue的想法是，每次直接弹出第一个，不管它是不是active，都设成active，再马上重新入队到最后，然后直接使用它的reference，这样就不会出现池子被用光的情况，哪怕queue里所有对象都是active了，fetch也会弹出第一个（也就是最老的最早被active的那个），然后去复用它，如此不断循环。当然其实这不会出现，因为在使用的时候，我们就要预估好用量，保证预生成的池子足够用，同时还要在该对象的prefab上挂好脚本处理OnEnable的逻辑，保证对象在被active后，过几秒马上就会inactive回收，而fetch是由Input触发的，哪怕是negev连发每秒也最多几十次，fetch的速度应该是跟不上回收的速度的。
ObjectPool的脚本要挂载在枪、魔杖或其他武器的发射口上，这样生成的子弹的parent直接就是武器本身，且position和rotation直接就是parent的值，不用再去做运算，然后直接给子弹ammo的刚体加一个初速度，最后再start一个coroutine去在几秒后回收它。
对象池的设置，每个prefab生成多少个amount，这个是要根据不同的对象去fine tune的，要在游戏中具体测试下，才能找到最优的amount，正好够用又没有浪费。具体测试的时候，用最大速度连发，然后盯着Hierarchy窗口，如果发现对象全都active，说明数量不够，如果最后几个对象始终是greyed out的，那么就够用了。
我的对象池是通用的，只管预生成object，并在被fetch的时候active一个返回给caller，而不需要去关心caller拿到对象后去做什么。对象始终都在池子里，只不过active状态会变而已。对象本身的脚本，负责实现各种方法以及何时回收，而caller则是负责何时去调对象的方法。对象池自己并不关心这些，它假定caller和对象自己会处理好一切，在短时间内一定会回到inactive的状态。如果出现了问题，不会是池子的问题，要么是caller和对象自己的class没处理好，要么是生成池子的时候amount太小数量不够。

可以给每个自己写的脚本，甚至每个gameobject设置自定义的icon图标，这个很有意思，可以方便我们辨别不同的脚本。
https://forum.unity.com/threads/gamemanager-cs-icon.539596/

------------------------------------------------------------------------------------------------------------
如何在一个脚本里调用另一个脚本的方法？比如player有一个TakeDamage的方法，而游戏中很多其他物体都可能call它，不光是enemy还有地形效果和buff和item效果等等。最直接的办法是在每个可能会是caller的脚本里，设置一个SerializeField变量来拖拽存储player的go，这样就能利用这个变量直接call，但是如果call的地方太多了呢？比如TakeDamage非常通用，到处都在call它，每次都这样设变量在编辑器里拖拽，又麻烦又杂乱，设计很糟糕，那怎么办？
UnityEvents是用来存放一堆functions的容器，在editor中可以拖拽不同的function进去，告诉某个脚本要执行哪些event，显然不是用来干这个的。
SendMessage已经不适合现在的版本了，不要使用，性能慢且design很差，BroadcastMessage也是同理。除非？画面左上角做一个游戏内的console，可以输入console命令做设置？可能需要用到SendMessage？
那就只能GetComponent了，但是一定要每次都这样做吗？有没有更好的办法？
想了下，应该是没有的。因为这种情况下，你call的那个方法如果不是static的话，必然是在某个已经生成的class instance上call的，所以无论如何都需要有一个该instance（在Unity中也就相当于player go）的reference，如果不拖拽hook up上，那就只能用findWithTag这种更慢的办法了。如果你想把那个方法wrap封装一下，在别的地方随意call，也是不可能的，因为能随意call的只有class的static方法，对于非static方法，是不能把它封装成为static的。换句话说，想要有universal的调用方式，那么必须是针对static方法，而依赖于某个go或instance的方法是无论如何也做不成universal的。试想一下，在playerManager里，playerController已经被成功的hook上了，你想一劳永逸，写个方法PlayerTakeDamage()，在里面去操作在playerController，然后想让外面能随意call它而不用重复hook playerController，这是不可能的，因为要达到这个目的的话，PlayerTakeDamage()必须是static的，而一个static函数体内，是不能access非static的东西的，所以矛盾。换个角度想，这样的设计其实并不糟糕，或者说这样才对，因为在任何一个会deal damage的go上，都应该显式的有一个damage receiver，才符合逻辑。

反正是单机游戏，只有一个player，用singleton也是可以的，而且playerStatus只管理玩家数据而已。或者干脆就用一个static class算了，但是那样的话没法save和load，不适合序列化。这个设计的问题，解决方案不仅要考虑到player数据可以单例的全局访问，还要考虑到怎么序列化save load，怎么persist between scenes。

ScriptableObject也是global access的，可以是singleton的一个很好的替代。
------------------------------------------------------------------------------------------------------------
GetComponent<T>()是generic泛型的版本，返回的直接就是该泛型T(就是某个class的类型，比如某个script的class名字)，然后可以直接操作调方法了。
GetComponent(typeof(someType))返回的是component，用于获取某个component。通常我们是要对someType的方法进行操作，所以用之前还需要先cast一下：(someType) GetComponent(typeof(someType))。显然，用generic的版本更加便捷。

if (x > 10) { _animator.setBool('Walk', true)}  // don't write like this
_animator.setBool('Walk', x > 10)  // nice one
Vector3? point = ...  // type后面的问号代表这个变量可能是该type，也可能是nullable type
------------------------------------------------------------------------------------------------------------
TextMeshPro的text不要直接修改，如果每次都给text赋值一个新的字符串，每个update都要产生待GC的垃圾，其他UI text也是同理。用TextMeshPro.SetText()方法可以避免不必要的垃圾，该函数有多个版本，而且还可以使用StringBuilder作为参数。对于Timer这种主要是数字的text，最底层的garbage-free的办法是用TextMeshPro.SetCharArray()方法，传入一个char数组，但要手工update每个char，有点麻烦。事实上不用麻烦，就用SetText就可以了，看了下源码，SetText里面就是用的SetCharArray，内部有一个唯一的char数组，每次只会更新变动的char，不过要保证用的是带arg的版本，SetText(string text, float arg0, float arg1, ...)，而不是SetText(string text, bool syncTextInputBox = true)这个会产生垃圾的版本。

Time.fixedDeltaTime是一个常数，和游戏FPS无关，可以在project settings里面设定，默认是0.02f。Time.fixedDeltaTime并不是两个FixedUpdate call之间的间隔时间，这点非常容易搞错，不管是Update还是FixedUpdate，间隔时间都是Time.deltatime。
还有个很大的误区是以为FixedUpdate is called at fixed time steps，因为它名字里有个fixed，然而实际上并不是，这个fixed与现实世界的时间没任何关系，并不是每隔fixed时间间隔就会被call的，具体的频率由Unity决定。FixedUpdate只用于simulate Physics，不要把其他的每x秒更新的逻辑放在FixedUpdate里，不要在FixedUpdate中使用任何非Physics的代码。

MonoBehavior是个类，但首先是个Behavior，是控制go在unity中如何behave的类，我们通过inherit它来写自己的behavior，这些behavior是通过component的形式来实现的，然后用component来操纵游戏中的go。所以可以说，我们主要是面向component编程的，component是Unity游戏主要的架构模式，component总是和go紧密关联在一起。问题在于，大量的go和component在切换场景的时候，重新load的时候，是要被destroy的，非常的零散，而且无法persist across scenes。所以在大局观上，MonoBehavior并不是用来存放数据的地方，只定义我们的行为。
ScriptableObject虽然也是继承mono的，但它不与任何的go或component或prefab关联，自带序列化功能，适合包装和存放数据，并且能share across scenes，也很便于transfer到其他项目。ScriptableObject适合用于存放player或enemy的数据，然后在mono的行为脚本里，我们可以去reference它，把数据和行为的代码分离。还可以用来存放inventory的数据。甚至是整个场景的level data，配合上JsonUtility的序列化功能。到时候看看save load用这个怎么样。

LateUpdate() is called after all Update functions have been called but before redrawing the scene，记住a follow-camera should always be updated in LateUpdate！！

C#有自带的Timer和Stopwatch类，时间可以非常精准，当处理precision critical逻辑比如数据库和登录时间的时候，都要用这两个。但是在Unity中，还是用我自己写的那几个包括cooldownCounter的类，因为游戏里的event要和Unity的Time.deltaTime等时间挂钩，需要根据time scale和FPS变化而变化，而不应该参照绝对的系统时间。用C#自带的Timer类的话，是没办法处理time scale的问题的，哪怕我们永远不会设置游戏的timeScale，始终用默认值，也无法保证Unity的timeScale和绝对的系统时间是同步的，无法保证该timeScale和现实世界的同步率为1.

有些脚本的名字是Unity保留的关键字，比如Folder，Audioclip，GameManager，Search之类的，当你创建一个同名的脚本时，Unity会自动给它一个图标。这对游戏本身没什么影响，但是和Unity自带的保留的功能可能会冲突，解决办法很简单，把你的脚本代码用一个namespace包起来，只要你用的是自己的namespace，而不是global的全局的namespace，就不会出现这个问题。

什么时候用abstract类，什么时候用interface，结合设计模式去考虑。
前者是is-a的关系，后者是has-a的关系。前者是inherit的关系，可以用virtual和override，后者是implement的关系，可以提供多个规范。
https://stackoverflow.com/questions/747517/interfaces-vs-abstract-classes

tag是用来处理批量的go的，如果某个tag只有一个go用，就显得有些没必要，但实际上这是为了性能，因为Find函数（通过name find）非常慢，会搜索全部scene的每一个go，但是findWithTag函数是优化过的，findGameObjectsWithTag也一样，只不过是返回所有该tag的go。使用tag时，脑子里先把go干净的分好类，想好tag，否则后面很乱会很难改。如果实在要find一个go，比如事先不知道该go在哪儿，或是该go要在游戏中后面才会生成，那么findWithTag是最优的选择，然而！！！通常我们都知道要找的是哪个go，所以其实可以不用在脚本里find，直接定义一个SerializeField变量，提前在编辑器中拖拽hook up上就行了，这样比findWithTag还要快很多，而且还能减少场景加载时间。

singleton模式要慎用，一个singleton的instance被创建以后，因为是在class内被instantiate的，所以它在程序运行时就永远存在而不会被gc掉。如果有很多个singleton，就会不必要的占据固定的内存。什么时候用呢？如果你需要一个class的实例数据，且该instance是在整个程序全局需要被共享的，且整个程序全局只能有一个该类的instance时，可以用。比如说，实现一个全局的GameManager，是全局共享的且只能有一个。再比如，单机游戏只有一个玩家，且玩家的数据本来就是要永远存在的，且游戏中各种地方都会去调用玩家的TakeDamage方法，那么玩家的class就可以做成singleton。数据库和服务器这种庞大的对象，虽然也是全局共享的单例，但千万不要做成singleton，会很占内存。而对于不大不小的全局共享对象，要不要做成singleton是看情况的，用了则会占用内存，但减少了CPU读写开销，不用的话省内存，但每次读写就会更消耗CPU，所以本质上是一个balancing act，在内存和CPU中间找平衡取舍，如果读写十分频繁的话，舍弃点内存节省CPU消耗还是很不错的。
singleton可以persist across scenes，不管有多少个scene，都能共享同一个singleton。
在Unity中使用singleton，还要额外注意，因为要继承monobehavior的话，没法保证singleton只有一个instance，哪怕构造函数的private的，我们依然可以在editor里拖拽脚本来创建多个singleton的实例，或者用Instantiate函数来创建实例，想避免这种情况，就要非常小心。

C#的internal关键字和C++的friend友元类似，但可能是个code smell，用的时候考虑好。Unity中不用考虑这么复杂，必须用到了再说。
Code smells are usually not bugs; they are not technically incorrect and do not prevent the program from functioning. Instead, they indicate weaknesses in design that may slow down development or increase the risk of bugs or failures in the future.

conversion和cast是完全不同的，所以(int)x和Convert.ToInt32(x)有本质的区别，但这个问题极其复杂，具体用到了case by case搜一下。。。

c#里面的struct是value-type而不是reference-type，因此不能修改struct里某个field的值。class类型以及C#9.0新推出的record类型都是referene-type，而原始类型比如int，float，string这些是value-type，这很好理解，但要注意struct也是value-type，不能当成class用，另外还有tuple也是的，所以tuple或struct一旦被创建，就是一个内存里的常量值，不能修改某个field，想修改变量的值必须要创建一个新的struct或tuple。这点和C++是不同的。In practice，struct臭名昭著有很多坑，尽量避免使用，如果要用的话，一定要用immutable版本的struct，定义readonly struct，以防出错。

Input在水平和垂直的axis上的值对于键盘和手柄通常是-1到1之间，0代表没动，只有鼠标的移动是例外，可以在（-1，1）区间之外。GetAxis会返回(-1,1)之间的一个浮点数，做过smooth处理了，步长是0.05f，但GetAxisRaw没有smooth和步长，所以值只会是-1、0、1三者其中之一，没有浮点数。

通常，我们计算速度时，是看Input的绝对值的，也就是0-1之间的一个值，再乘以一个multiplier和deltatime，如果xy两个axis同时按住input，走斜线是根号2，要比单独一个axis速度快，所以为了速度平衡，记住一定要做normalize处理。
normalize和clamp的区别是什么？normalize返回一个向量的unit单位向量的copy，模为1，换句话说，被normalized了以后，模永远是1。而clamp可以返回比1小的浮点数，0-1之间都可以。考虑一个从原点出发的单位球，一个normalized的向量永远只能触碰到球体的表面，却无法触碰到球体内部，但是clamp则可以触碰到整个球体空间内的任何一个位置，不止限于表面。所以通常情况下，用clamp，不要用normalize，对于单个浮点数，就用Mathf.Clamp，对于向量Vector2,Vector3,Vector4，用对应类的静态方法去clamp，比如Vector3.ClampMagnitude().

speed是一个标量scalar，是一个具体的float数值，velocity是一个向量Vector3，两者不要混淆。
Vector3.Equals用于判断两个vector3（可以是点或向量）是否完全相等，这很少会用到。一般用的都是Vector3重载的==符号，比如transform.position == other.position，这会判断这两个position是否近似相等，考虑了浮点数的精度误差，差值小于1e-5则认为相等。

the amount returned by Mouse X/Y or the scrollwheel can vary heavily from device to device so it's common to provide a sensitivity setting for the user to adjust. (use a [HideInInspector] public float sensitivity variable, which can be changed via the UI system later in-game) 这个设置后面加在UI里，让玩家可以自己调节，不要放在inspector里。

Mathf是Mono针对C#本身的Math库做了一个简单的封装，性能上是没什么差别的，原生的Math库是基于double类型操作的，Mathf库是基于float类型操作的，所以才叫做Mathf。Mathf的很多方法，其他类也有同名的方法，只是操作对象类型不同，换句话说，很多方法除了Mathf的版本之外还有其他版本。比如Mathf.SmoothDamp是对一个float进行平滑更新，对应到向量，则可以用Vector3.SmoothDamp，功能是完全一样的只不过是操作向量。Mathf还有Lerp和LerpUnclamped这种插值函数，同样的，对于其他类型，我们也有Vector4.LerpUnclamped，Quaternion.LerpUnclamped等等。

几种平滑和插值的比较：
Lerp is linear, works well for very fast movements, is less demanding on CPU，但是在首尾两端的移动会很sudden不平滑。
SmoothDamp follows a sigmoid function, looks more like the object is accelerating and decelerating, is more pleasant to the eye.
Slerp or Spherical Lerp is generally only applied to Quaternions, or at least vectors, not positions.
我们还可以设计自己的平滑函数，用sine和cosine wave就是很好的例子，它们定义域无限，而且还能调节amplitude和频率，还能配合clamp产生反弹效果等等。
------------------------------------------------------------------------------------------------------------
Mono format是单音轨，Stereo format是双音轨（左耳右耳），普通的音频都选force to mono，比如人物对话，UI音之类的，而BGM音乐和ambience音，以及cutscene和某些特效的音频，选stereo。

PCM是所有音频最终输出时候的目标格式（codecs），是lossless的格式，处于完全解压uncompressed的状态，占用内存大小等同于源文件original size。
ADPCM是一个压缩过的compressed格式，在Unity中，占用内存大小要比PCM格式小3.5倍，即大约是源文件大小的30%。压缩后最好试听一下失真的程度（一般听不出）。
Vorbis是比ADPCM更好的压缩格式，算法复杂，同等压缩大小下的音质更高，同等音质下压缩的更小，但当play的时候，解压会占用很大的CPU。
MP3是和Vorbis同等级的一个压缩格式，算法也很好，但MP3 cannot loop seamlessly，所以为了loop的衔接音质，一般prefer用Vorbis。

---When to load audioclips to memory：
【Preload Audio Data】 【load in background】
[Y] [Y] 只要该AudioClip在scene中被reference了，那么Unity会在load scene的同时load这个AudioClip，但load audio不会block主线程。scene加载好了就会进入play mode，剩下还没加载好的audio会在后台加载。
[Y] [N] 只要该AudioClip在scene中被reference了，那么Unity会在load scene的同时load这个AudioClip，没reference则不会load. load不会在后台发生，因此会block主线程，只有当audio也load好了以后，scene才会进入play mode。（最好的）
[N] [Y] Unity只有在该audio被调用到(play)的时候才会load，哪怕场景里有reference它。会消耗CPU，但不会block主线程，所以音效的defer可能会造成不同步。
[N] [N] Unity只有在该audio被调用到(play)的时候才会load，哪怕场景里有reference它。不仅消耗CPU，且会block主线程来load，所以虽然不会造成音效不同步，但可能会出现卡帧（frame hitch or frame freeze）。

更换场景的时候，Unity会自动在garbage collect的时候unload之前的audio，清理内存。
对于重要的SFX，都要在import的时候给Preload Audio Data打上勾。loading只占用加载场景的时间，不影响gameplay，所以多等一会儿没事儿，只要内存占用不过分。

---How to load audioclips to memory（Load Type）：
Decompress on Load：load音频的时候就顺便解压成目标PCM格式并放入内存中了，占用更多的内存，但不再消耗CPU，可以随时play。选了这个选项，音频在内存中的大小就是original size显示的数字，而不是imported size。适用于反复地频繁使用的较小的音频，如footsteps，攻击音效，UI按钮音等等。
Compressed in Memory：load到内存的时候，在内存中依然保持压缩的状态，直到被play的时候才会解压。占用内存较小，但play时需要先消耗CPU来解压。play结束后，解压过的数据就会消失，下次再play时还要重新消耗CPU来解压。适用于不太经常会被用到的，偶尔才会play的音频。

---streaming
音频不会被load到内存，只有在play用到的时候才会当场从磁盘读取数据，放入内存，再解压。因此，平时完全不占用一点点内存，但play时CPU会瞬间飙升。适用于size最大的例如BGM和环境音这种音频文件。

一言以蔽之，音频的问题就是，在文件大小（占用内存大小），runtime CPU消耗，以及音质三者之间寻找平衡。。。。。。
------------------------------------------------------------------------------------------------------------
关于coroutine：
yield return null;  // wait until the next frame (temporarily return, then continue execution in the next update)
yield return new WaitForSeconds(5f);  // wait for a period of time
WaitForSeconds delay = new WaitForSeconds(3f);  // cache the WaitForSeconds object for repeating delays
yield return delay;
...
yield return delay;
yield return new WaitForSecondsRealtime(5);  // uses unscaled time
yield return new WaitUntil(IsEmpty);  // pauses execution until a bool delegate/lambda function evaluates to true
yield return new WaitWhile(() => fuel > 0);  // waits for a bool delegate/lambda function to be false before proceeding
yield return new WaitForEndOfFrame();  // waits until the frame is ready
yield return StartCoroutine(OtherCoroutine());  // Wait for another Coroutine

Coroutine co = StartCoroutine(MyCoroutine());  // don't use the string version, store it in a var if u wanna stop it later
yield break;  // end from inside of a Coroutine
StopCoroutine(co);  // end from outside of a Coroutine, don't use the string version
StopAllCoroutines();  // stops all Coroutines started by this script, even if the Coroutines are in another script.
                      // e.g. if script A starts coroutines in script B, this must be called in A, but does not work in B.

Coroutines end themselves once they complete.
Coroutines are tied to the Game Object that called them, so destroying/disabling the go will end any Coroutines that were called from it, even if they're in other scripts on other gos, but disabling the script won't stop it since the go still exists. If a Coroutine on go A was called by a script in go B, destroying/disabling go A won't end the Coroutine.
Coroutines只是一种multitasking的便捷处理方式，但并不是多线程，其实还是在单线程里以interleaving的方式跑的，主要用于拆分逻辑，适用于轻量的小函数。Coroutines是UnityEngine特有的一个封装的函数，没有返回值。
Async/Await才是真正的多线程异步，是C#原生的语法，是non-blocking的，适用于重量的运行时间长的routines，且可以有return values。功能更强大，支持一切代码，且不会有内存leak的问题，难点在于要手动处理concurrency避免race conditions。相比之下，Coroutines如果挂载的go被意外或不当地destroy，会有内存泄露。
游戏内的小逻辑，fire-and-forget的routines就用Coroutines处理就够了，增加可读性。但对于例如数据IO传输、网络层通讯这种重要功能，一定要用Async/Await。

// invoke函数也可以达到同样效果，但性能和灵活度不如coroutines，尽量避免使用。
// invoke的对象方法只能接受最多一个参数，有限制。而StartCoroutine(MyCoroutine(arg0, arg1, arg2, ...))随便来几个参数都可以。
Invoke()  // delay a function call
InvokeRepeating()  // delay a function call and repeat it every x seconds
------------------------------------------------------------------------------------------------------------
Rider里对于已经build过的脚本文件，原来还可以查看IL（CIL中间语言）代码，相当于汇编，可以用鼠标查看每个命令的含义什么的用于调优。

You can multiply the Quaternion and the Vector3 and you'll get back a Vector3 that has been rotated by that Quaternion:
Vector3 rotatedDirection = transform.rotation * direction;

TransformPoint vs TransformDirection vs TransformVector
https://answers.unity.com/questions/1021968/difference-between-transformtransformvector-and-tr.html

When using coroutines for physics calculations be sure to use WaitForFixedUpdate NOT WaitForUpdate.
Keep your game within 6000 units of the origin.
Keep your forces below 10,000 Newtons.
Keep your masses bellow 10000 kg and above .01 kg.

Unity allows many objects to have the same name, but every object has a unique Instance ID.
It is good practice to include an object's instance ID as well as its name in debug statements:
Debug.Log(go.name + ":" + go.GetInstanceID());
Instance ID非常容易获取，对于任何一个go，只要点击它的Inspector的右上角（lock图标旁边），将normal切换成debug进入debug mode，那么Inspector就会自动显示出每个component的Instance ID，同时还会显示出脚本里的private变量（灰色的，只是显示，不能修改）的最新值。在debug模式下，如果脚本里的某个方法前面标注了[ContextMenu("...")]，还可以直接right click那个脚本component，在菜单中选择那个方法的名字，于是该方法就会被手动的调用一次，这样我们可以很方便的看到方法是不是起作用了。

Vector3.Distance(a,b) is the same as (a-b).magnitude，性能上几乎一样，通常不用纠结，除非是循环做几万次这个操作，具体哪个快取决于CPU的FPU（floating point coprocessor），要在不同的设备上试一试。如果是比较两个向量的长度（模），不要用magnitude，而是去比较模的平方，比较Vector3.sqrMagnitude，这样减少了两个开根号的操作会更快，因为Mathf.Sqrt是比较复杂的，比乘法慢很多。比较时千万不要用==判断，因为浮点数是有精度问题的，要用Mathf.Abs(x,y) < episilon。
